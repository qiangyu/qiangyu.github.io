<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiao Yu</title>
  
  
  <link href="http://zqyu.top/atom.xml" rel="self"/>
  
  <link href="http://zqyu.top/"/>
  <updated>2023-03-23T10:26:18.093Z</updated>
  <id>http://zqyu.top/</id>
  
  <author>
    <name>Xiao Yu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap一些误区</title>
    <link href="http://zqyu.top/Java/basics/HashMap/"/>
    <id>http://zqyu.top/Java/basics/HashMap/</id>
    <published>2023-03-23T10:05:05.000Z</published>
    <updated>2023-03-23T10:26:18.093Z</updated>
    
    <content type="html"><![CDATA[<p>1.8 HashMap一些误区</p><p>待更新</p><span id="more"></span><div class="story post-story"><h2 id="触发treeifyBin方法情况（java-util-HashMap-treeifyBin）"><a href="#触发treeifyBin方法情况（java-util-HashMap-treeifyBin）" class="headerlink" title="触发treeifyBin方法情况（java.util.HashMap#treeifyBin）"></a>触发treeifyBin方法情况（java.util.HashMap#treeifyBin）</h2><ul><li><p>在进行插入元素时，遍历链表进行尾插入，紧接着会判断当前链表长度是不是大于TREEIFY_THRESHOLD（8），条件成立则进入treeifyBin方法尝试转为红黑树。但是该方法内部还会判断当前数据长度是否小于MIN_TREEIFY_CAPACITY（64），小于则扩容，大于则转红黑树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div><div class="story post-story"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>并不是链表长度超过默认值8就会转换为红黑树，还会判断数组是否会大于64。小于则扩容、大于则转换红黑树。</li></ul><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/qiangyu/qiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.8 HashMap一些误区&lt;/p&gt;
&lt;p&gt;待更新&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="Map" scheme="http://zqyu.top/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="http://zqyu.top/MySQL/update%E8%AF%AD%E5%8F%A5%E5%AF%BC%E8%87%B4%E8%A1%8C%E9%94%81%E6%88%96%E8%80%85%E8%A1%A8%E9%94%81/"/>
    <id>http://zqyu.top/MySQL/update%E8%AF%AD%E5%8F%A5%E5%AF%BC%E8%87%B4%E8%A1%8C%E9%94%81%E6%88%96%E8%80%85%E8%A1%A8%E9%94%81/</id>
    <published>2022-09-17T14:10:16.000Z</published>
    <updated>2022-09-17T15:29:33.406Z</updated>
    
    <content type="html"><![CDATA[<p>关于MySQL使用update语句时where条件使用不恰当导致表锁</p><span id="more"></span><div class="story post-story"><h2 id="结论一（where语句后面没有order-by排序）"><a href="#结论一（where语句后面没有order-by排序）" class="headerlink" title="结论一（where语句后面没有order by排序）"></a>结论一（where语句后面没有order by排序）</h2><ul><li>当where条件使用上索引，则进行行锁<ul><li>使用对应索引列进行遍历对比，找到对应索引记录加锁</li></ul></li><li>反之则进行表锁<ul><li>当where条件没有可用的索引列，那只能通过主键索引逐一遍历比较</li><li>遍历过的索引项都会被加上next-key锁（记录锁 + 间隙锁）（对记录加锁的基本单位时next-key锁），直到找到符合条件为止，因此后面的索引项不会被锁住，并不是完全的全表锁住</li></ul></li></ul></div><div class="story post-story"><h2 id="结论二（where语句后面有order-by排序）"><a href="#结论二（where语句后面有order-by排序）" class="headerlink" title="结论二（where语句后面有order by排序）"></a>结论二（where语句后面有order by排序）</h2><ul><li><p>当where条件和order by都分别有单列索引时</p><ul><li><p>不在是先根据where条件查询出来然后再排序，而是先根据order by字段的索引找出记录</p></li><li><p>若是order by desc，则在索引最右侧叶子节点倒序批量取出记录，再根据查询出的id回表查询出完整记录，根据where条件判断是否符合</p></li><li><p>因为索引是按照时间顺序从左到右插入，因此MySQL优化器觉得先根据order by索引树倒序批量取出数据会比根据where条件筛选出数据再排序快得多</p><p>认为如果排序不用索引，将会是file sort，又不能where和order by两个索引都用上，所以选择用order by的索引</p><p>为什么不能用上两个索引？</p><p>每个索引在数据库中都是一个索引树，对于主键索引，其节点存储了只想实际数据的文件指针，查询其原理就是在索引树上遍历，获得叶子节点的文件指针，取出对应数据；而唯一索引等，叶子节点存放主键id，根据主键id到主键索引上查询到对应的叶子节点，取出对应的数据</p><p>当MySQL使用一个索引之后，还要再使用另一个索引，则会得到两组集合，并且要给这两个集合取交集才得到结果，当数据量较大时，复杂度高，效率低，即用多个索引不仅没用，还是得效率更低</p></li></ul></li><li><p>当where条件和order by是组合索引时</p><ul><li>根据where条件在组合索引遍历查询，得到的数据就是有序的（从左往右遍历即是正序，反之倒序）</li><li><a href="https://zhuanlan.zhihu.com/p/356463167" target="_blank" rel="noopener external nofollow noreferrer">https://zhuanlan.zhihu.com/p/356463167</a></li></ul></li></ul></div><div class="story post-story"><h2 id="为什么很多人在update语句假limit-1？"><a href="#为什么很多人在update语句假limit-1？" class="headerlink" title="为什么很多人在update语句假limit 1？"></a>为什么很多人在update语句假limit 1？</h2><ul><li>避免条件错误导致批量更新</li></ul><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/qiangyu/qiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于MySQL使用update语句时where条件使用不恰当导致表锁&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://zqyu.top/categories/mysql/"/>
    
    
    <category term="MySql" scheme="http://zqyu.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean的this调用导致其注解失效原因</title>
    <link href="http://zqyu.top/Spring/Spring%20Bean%E7%9A%84this%E8%B0%83%E7%94%A8%E5%AF%BC%E8%87%B4%E5%85%B6%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0/"/>
    <id>http://zqyu.top/Spring/Spring%20Bean%E7%9A%84this%E8%B0%83%E7%94%A8%E5%AF%BC%E8%87%B4%E5%85%B6%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0/</id>
    <published>2022-08-02T07:46:27.000Z</published>
    <updated>2022-08-02T09:33:26.580Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Bean的this调用导致其注解失效原因</p><span id="more"></span><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/qiangyu/qiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Bean的this调用导致其注解失效原因&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第四次面试复盘</title>
    <link href="http://zqyu.top/interview/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
    <id>http://zqyu.top/interview/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</id>
    <published>2020-07-31T02:38:40.000Z</published>
    <updated>2020-07-31T03:41:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>第四次面试复盘</p><span id="more"></span><div class="story post-story"><h2 id="第四次面试是在外面的世界，xxx公司（好像是培训公司，但是没和我说培训的事情）"><a href="#第四次面试是在外面的世界，xxx公司（好像是培训公司，但是没和我说培训的事情）" class="headerlink" title="第四次面试是在外面的世界，xxx公司（好像是培训公司，但是没和我说培训的事情）"></a>第四次面试是在外面的世界，xxx公司（好像是培训公司，但是没和我说培训的事情）</h2><ul><li>去到公司门口，各种调查，粤康码、身份证什么什么的（毕竟是珠江新城的某一栋大楼）</li><li>上到公司，又需要填写资料</li><li>去到接待室那边填写，填写完成后和简历一起交给前台小姐姐（前台小姐姐都那么漂亮的嘛），接着等待面试</li><li>和我一起来的那个人进去20来分钟，才到我....</li><li>别人面试都有小房间，就我在外面面试....</li><li>面试开始..<ul><li>自我介绍</li><li>问我最近情况、住哪、下半年还要不要回校上课、学校的课程主要是学些什么、学校有没有实训什么的、是学校强制的还是自愿实训的、以后有什么打算（为后面洗脑培训做准备？）</li><li>接着，SpringMVC流程，大概说一下（这个转变我有点转不过来，懵了一会）</li><li>SpringMVC常用的注解</li><li>SpringBoot自动配置原理</li><li>Mybatis二级缓存</li><li>MySQL的事务（好像忘记这个问题了...）</li><li>提示事务？？（听得不太清楚...）</li><li>我直接打断面试官，说我SpringBoot、Mybatis目前的阶段只是会用，还没到了解其原理的地步，但是我对Spring有所了解，尤其是IOC和AOP</li><li>接下来面试官没问我Spring的任何问题</li><li>问到了我Redis了解过一点没有</li><li>那么如何实现Redis的读写分离？</li><li>我.....</li><li>你知道有哪几种算法？</li><li>学过数据结构是吧，有哪几种结构？</li><li>讲讲线程有哪几种状态？</li><li>讲讲位于运算的过程？</li></ul></li><li>就以上这些问题，比我早进去20来分钟的都没出来，我又是面试时间最短的，太难了.....</li><li>并且面试官也是女的，至于漂不漂亮，和前台小姐姐和差得远呢...</li></ul><h3 id="面试总结：还是需要对SpringBoot、Mybatis、Redis等技术的原理深入了解"><a href="#面试总结：还是需要对SpringBoot、Mybatis、Redis等技术的原理深入了解" class="headerlink" title="面试总结：还是需要对SpringBoot、Mybatis、Redis等技术的原理深入了解"></a>面试总结：还是需要对SpringBoot、Mybatis、Redis等技术的原理深入了解</h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;第四次面试复盘&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://zqyu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>第三次面试复盘</title>
    <link href="http://zqyu.top/interview/%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
    <id>http://zqyu.top/interview/%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</id>
    <published>2020-07-29T14:23:41.000Z</published>
    <updated>2020-07-31T03:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三次面试复盘</p><span id="more"></span><div class="story post-story"><h2 id="第三次面试是在外面的世界-，xxx公司"><a href="#第三次面试是在外面的世界-，xxx公司" class="headerlink" title="第三次面试是在外面的世界.....，xxx公司"></a>第三次面试是在外面的世界.....，xxx公司</h2><ul><li><p>去到公司，一抬头就看到隔壁是培训机构，我呃.........</p></li><li><p>走进公司前台，日常签个名，然后给了份面试题做，优势笔试....还全部要手写理论，回忆有点不全面，忘了拍下来.....（共有12道题目，前台小姐姐说能写多少是多少）</p><ul><li>String、StringBuffer和StringBuilder三者之间的区别</li><li>List、Set与Map的区别</li><li>servlet生命周期</li><li>Spring的AOP原理</li><li>get、post区别</li><li>左连接查询（left join）、自连接查询（inner join）、右连接查询（right join），谈谈你对这三种连接的理解</li><li>Mybatis调用mapper接口需要注意什么?（记得不太清除）</li><li>forward和redirect之间的区别</li><li>BeanFactory与ApplicationContext的区别</li><li>servlet与jsp的关系 &#x2F; 区别</li><li>画出SpringMVC流程图</li><li>SpringBoot的starter有什么作用，作用在哪里？有哪些常用的starter？</li></ul></li><li><p>写完笔试，拿出简历一起给前台小姐姐，就开始漫长的等待.....</p></li><li><p>没错，又是我最后一个。作为最后一个面试的我，表示很淡定</p></li><li><p>面试官的问题如下，想起多少是多少......</p><ul><li>SpringBoot自动配置的原理？</li><li>SpringBoot的starter有什么作用？</li><li>接下来我直接说我SpringBoot只是会用这种程度...</li><li>Mybatis？（我直接说不会....）估计是问二级缓存问题</li><li>BeanFactory与ApplicationContext区别！</li><li>讲讲AOP原理？</li><li>注意（SpringMVC没问到我）</li><li>ConcurrentHashMap与HashMap的区别？</li><li>原来上一个是我听错了....是HashTable与HasMap区别？</li><li>讲讲你所理解的HashMap！</li><li>当我说到加载因子是0.75时，面试官打断提问，为什么是0.75？</li><li>说一下MySQL有哪两种常用的引擎？</li><li>那它们（MyISAM、InnoDB）分别有什么区别？</li></ul></li><li><p>问到这里就结束啦，是不是感觉很简单....</p></li><li><p>注意，我回答问题的过程中，面试官曾多次打断我的回答（只有两种情况：一是回答的太糟糕了，面试官都听不下去、二是你回答到了面试官的点上，让面试官get到你会了这个问题）</p></li><li><p>回答完毕，出来等面试的情况</p></li><li><p>面试官对我的面试给下了如下的结果：Java基础扎实、对Spring源码有所了解、SpringBoot会用，但是不了解其原理、MySQL基础扎实（这个我是我自己觉得的【狗头】）</p></li><li><p>最后给项目回家实现，一天后提交项目（我放弃了....原因不是做不出...很扎心）</p><blockquote><p>设计员工表（Employee）有以下字段</p><p>​    id，年龄，姓名，性别，地址</p><p>注册git账号（coding，码云都可以）：</p><p>\1.   手动搭建SSM框架，不能使用springboot搭建，需要手动原生spring整合。</p><p>注意：需要用Maven进行管理、尽量遵循resultful开发风格</p><p>（需要加入统一异常处理和事务管理）</p><p>整合完成后运行，找错，运行无问题后，将运行截图在world文档中，完成后上传一个git。</p><p>\2.   完成员工增删改查开发，返回json数据即可。需要在添加员工和修改员工加入springmvc校验处理，校验字段是否合法，尽量遵循resultful开发风格。运行无问题后，将运行成功截图在word文档中，完成后上传一次git。</p><p>\3.   编写发送短信验证接口，可以对接（阿里大于，互亿无线等短信平台），短信发送无问题后，将运行成功截图到word文档中，完成后上传一次git。</p><p>\4.   设计一个单点登录系统，实现手机验证码登录和找回密码，登录信息使用jwt无状态存储。</p><p>\5.   对接蚂蚁支付沙箱环境，对接完成后使用springcloud搭建字符微服务，在支付异步通知使用zookeeper实现分布式锁。</p><p>\6.   将支付微服务项目发布到linux服务器中，可以在虚拟机安装centos7，可以直接使用linux发布也可以使用docker，将发布成功运行成功截图到word文档中。</p></blockquote></li></ul><h3 id="面试总结：基础虽然扎实，但是对框架的原理不是很理解，需要加深这方面的知识！！！"><a href="#面试总结：基础虽然扎实，但是对框架的原理不是很理解，需要加深这方面的知识！！！" class="headerlink" title="面试总结：基础虽然扎实，但是对框架的原理不是很理解，需要加深这方面的知识！！！"></a>面试总结：基础虽然扎实，但是对框架的原理不是很理解，需要加深这方面的知识！！！</h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;第三次面试复盘&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://zqyu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>第二次面试复盘</title>
    <link href="http://zqyu.top/interview/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
    <id>http://zqyu.top/interview/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</id>
    <published>2020-07-29T02:20:47.000Z</published>
    <updated>2020-07-31T03:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>第二次面试复盘</p><span id="more"></span><div class="story post-story"><h2 id="第二次面试是微信上线以及到公司面试-，xxx公司"><a href="#第二次面试是微信上线以及到公司面试-，xxx公司" class="headerlink" title="第二次面试是微信上线以及到公司面试.....，xxx公司"></a>第二次面试是微信上线以及到公司面试.....，xxx公司</h2><ul><li><p>这个简单啊，有个妹子内推我去面试，首先要在微信上线面试摸一下我的底</p></li><li><p>接下来我直接复制微信上的记录吧，都是些经典的问题....</p><ul><li><p><strong>你好，技术面试官吴总会安排时间与你交流@吴珊</strong> </p></li><li><p>好的，麻烦你们了</p></li><li><p><strong>@小猪爱生活 先介绍一下自己擅长的开发领域是什么吧</strong></p></li><li><p>小猪爱生活:<br>我擅长的开发领域是Java后端开发，目前用的框架springboot以及SSM，对于springboot能够熟练运用，熟练spring的ioc，aop原理，springmvc执行流程，大概是这个样子</p></li><li><p>使用springboot框架的项目如何在linux上运行？</p></li><li><p>前台运行：java -jar jar包</p></li><li><p>如果要加上一些jvm的参数在后面追加，但是我还了解到那个程度</p></li><li><p>后台运行：nohup java -jar jar包 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</p></li><li><p><strong>嗯，讲一个你开发过的项目，其中设计到的技术，难点，对难点的解决方法</strong></p></li><li><p>项目记录日志吧，我需要将登陆的日志和操作的日志分开来记录，并且具体操作的方法都是以power开头的，power开头的方法能够使用aop统一来管理权限</p></li><li><p>但是有个功能，修改用户信息，这个功能按道理来说是需要权限认证的</p></li><li><p>但是有一种场景，用户修改个人信息时，也会调用到这个api，如果这个用户是普通用户，则会被权限拦截，无法进行修改操作</p></li><li><p>我不想再新写一个方法专门用来进行 用户的信息修改</p></li><li><p>所以只能将这个修改用户信息的方法从aop抽出来，单独判断权限等问题</p></li><li><p>所以这个修改用户信息的方法不是以 power  开头，当记录权限的时候，没办法一条切入点表达式  切完整个操作的方法，最后采用自定义注解解决</p></li><li><p>还有就是，部门的信息时采用树型的结构展示，所以存储再数据库时是树型的数据，我采用的是直接记录父节点的方式，这样的话，需要递归查询出来，当树的深度 达到一定程度时，查询效率变慢</p></li><li><p>这也是近期准备优化项目的一个问题，性能</p></li><li><p>以为部门插入少，查询多，以空间换时间的方法来优化</p></li><li><p>这个问题的话采用，采用树的前序遍历，存储在数据库上</p></li><li><p><strong>截一段你认为写的最好Java的代码给我看看</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="type">Long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 登陆日志的</span></span><br><span class="line"><span class="keyword">if</span> (log <span class="keyword">instanceof</span> LogLogin) &#123;</span><br><span class="line">    list = logMapper.findLogLoginByPage(page, size, (LogLogin) log);</span><br><span class="line">    total = logMapper.getLogLoginTotal((LogLogin) log);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作日志的</span></span><br><span class="line"><span class="keyword">if</span> (log <span class="keyword">instanceof</span> LogOperating) &#123;</span><br><span class="line">    list = logMapper.findLogOperatingByPage(page, size, (LogOperating) log);</span><br><span class="line">    total = logMapper.getLogOperatingTotal((LogOperating) log);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() == <span class="number">0</span> || total == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultBean.error(<span class="string">&quot;查询不到日志信息！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ResultBean.ok(<span class="keyword">new</span> <span class="title class_">ResultPageBean</span>(list, total));</span><br></pre></td></tr></table></figure></li><li><p>虽然代码蛮简单，但是一个方法实现了两种不同的查询，利用  instanceof  关键字来判断具体执行哪种操作，这个是我看到spring源码那些后置处理器学到的，spring不同的后置处理器处理不同的事物</p></li><li><p><strong>ok,你有什么需要问的吗?</strong></p></li><li><p><strong>本次技术面试结束，感谢你的参加，后续将由HR交流，本群解散。</strong></p></li><li><p>接着我还没问面试官问题就被踢出了群....</p></li></ul></li></ul><h3 id="面试总结：这个没什么好总结的，基本上问我项目，没问什么技术问题。"><a href="#面试总结：这个没什么好总结的，基本上问我项目，没问什么技术问题。" class="headerlink" title="面试总结：这个没什么好总结的，基本上问我项目，没问什么技术问题。"></a>面试总结：这个没什么好总结的，基本上问我项目，没问什么技术问题。</h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二次面试复盘&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://zqyu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>第一次面试复盘</title>
    <link href="http://zqyu.top/interview/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
    <id>http://zqyu.top/interview/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</id>
    <published>2020-07-28T15:23:52.000Z</published>
    <updated>2020-07-31T03:41:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次面试复盘</p><span id="more"></span><div class="story post-story"><h2 id="第一次面试是在学校的图书馆，xxx公司"><a href="#第一次面试是在学校的图书馆，xxx公司" class="headerlink" title="第一次面试是在学校的图书馆，xxx公司"></a>第一次面试是在学校的图书馆，xxx公司</h2><ul><li>首先去到那里什么都不管，先笔试</li><li>笔试的的题目吧，记得不太清楚了.....难顶<ul><li>类初始化时，构造器代码块、局部代码块、静态代码块的执行顺序，在博客的另一篇文章不再过多细谈。</li><li>StringBuffer与StringBuilder的区别，在博客的另一篇文章不再过多细谈。</li><li>new String(&quot;&quot;)与String str &#x3D; &quot;&quot;有什么区别：前者new String是不管常量池有没有，都是new一个、后者在常量池中找有没有这个对象，有就直接指向这个对象，没有就new一个</li><li>new StringBuilder(&quot;hello&quot;).append(&quot;world&quot;) <strong>&#x3D;&#x3D;</strong> String str &#x3D; &quot;helloworld&quot; ? true <strong>OR</strong> false</li><li>选择题基本就这些比较重要吧.....</li></ul></li><li>做完笔试坐等面试，因为我是最后一个面试Java后端的，等着就比较着急。看着在我之前的大佬，面试时间是真的久，顿时很慌</li><li>仿佛过了一万年，终于到我了，拿着简历慌慌张张的走进去。面试官：你先自我介绍下.......</li><li>我：..........难顶</li><li>我的自我介绍：我是谁，来自于哪个学校哪个专业，目前有两个项目经验。接着就详细的介绍我的那两个项目</li><li>在自我介绍期间，被打断几次，然后思路发生了微妙的变化....就...莫名其妙的我就介绍完项目了..........</li><li>接着面试官开始讲话，咳咳：请问你这个部门管理的树形结构是如何实现的？能不能把它的表结构写出来？然后就给我一张纸一支笔，我......发生了什么事情...</li><li>既然都叫写了，总不能说不会吧，硬着头皮写出来。</li><li>接着问这个功能是怎么实现的，能不能说一下过程</li><li>我就巴拉巴拉巴拉...表结构就是指存储父节点的id，然后通过递归将它们查询出来</li><li>面试官：如果你这个树的深度是20层或者更多层的话，那要递归20次才能查询出来啊，效率很低啊，能不能说一说这个效率低在哪里，时间都浪费在哪里</li><li>我......</li><li>面试官：那你针对这个问题，有没有什么解决方案？</li><li>我：没有......</li><li>面试官：那你现在能不能想出一个方案给我？</li><li>我.......</li><li>面试官：那我问问你其他问题吧，你们学过数据结构的是吧？如果有一个长度为20的数组，需要找出16这个值，你会怎么做？</li><li>我：那这个数组是排好序的吗？比如是大到小或者是小到大？</li><li>面试官：大概想一秒钟，说是排好序的</li><li>那我接着说，用二分法查询吧</li><li>面试官：那它的时间复杂度是多少？</li><li>我：log.....（二分法的时间复杂度是 <strong>logN</strong> ）</li><li>面试官：好了，我大概了解你的情况了，那就先这样吧，到时候我们讨论下回告诉你面试结果的</li></ul><p>第一次面试就是这样，没错，问的问题很少，面试的时间也短，问到的都是我的弱项，我没办法接面试官的话说下去，好菜啊....</p><h3 id="第一次面试总结：自己需要加强MySQL数据库性能优化相关的知识、然后就是面试官问的问题，要get到面试官问的是什么场景下的问题，如果场景不清楚，可继续询问面试官是哪种场景，不同的场景的解决办法是不同的。"><a href="#第一次面试总结：自己需要加强MySQL数据库性能优化相关的知识、然后就是面试官问的问题，要get到面试官问的是什么场景下的问题，如果场景不清楚，可继续询问面试官是哪种场景，不同的场景的解决办法是不同的。" class="headerlink" title="第一次面试总结：自己需要加强MySQL数据库性能优化相关的知识、然后就是面试官问的问题，要get到面试官问的是什么场景下的问题，如果场景不清楚，可继续询问面试官是哪种场景，不同的场景的解决办法是不同的。"></a>第一次面试总结：自己需要加强MySQL数据库性能优化相关的知识、然后就是面试官问的问题，要get到面试官问的是什么场景下的问题，如果场景不清楚，可继续询问面试官是哪种场景，不同的场景的解决办法是不同的。</h3><h3 id="eg：部门管理用到的是树形结构，并且不经常增删改的，但坚持查询，这个时候就可需要优化查询，以空间换取时间来解决该问题。采用闭包表：https-www-biaodianfu-com-closure-table-html"><a href="#eg：部门管理用到的是树形结构，并且不经常增删改的，但坚持查询，这个时候就可需要优化查询，以空间换取时间来解决该问题。采用闭包表：https-www-biaodianfu-com-closure-table-html" class="headerlink" title="eg：部门管理用到的是树形结构，并且不经常增删改的，但坚持查询，这个时候就可需要优化查询，以空间换取时间来解决该问题。采用闭包表：https://www.biaodianfu.com/closure-table.html"></a>eg：部门管理用到的是树形结构，并且不经常增删改的，但坚持查询，这个时候就可需要优化查询，以空间换取时间来解决该问题。<a href="https://www.biaodianfu.com/closure-table.html" target="_blank" rel="noopener external nofollow noreferrer">采用闭包表</a>：<a href="https://www.biaodianfu.com/closure-table.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.biaodianfu.com/closure-table.html</a></h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一次面试复盘&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://zqyu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>HandlerAdapter</title>
    <link href="http://zqyu.top/SpringMVC/HandlerAdapter/"/>
    <id>http://zqyu.top/SpringMVC/HandlerAdapter/</id>
    <published>2020-07-05T13:00:16.000Z</published>
    <updated>2020-07-05T14:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>HandlerAdapter</p><span id="more"></span><p>​HandlerMapping将方法映射到URL，因此DispatcherServlet知道特定请求应该调用哪个方法。然后DispatcherServlet使用HandlerAdapter来调用该方法。</p><p>​SpringMVC通过HandlerMapping获取到可以处理的handler，这些handler的类型各不相同，对请求的预处理，参数获取都不相同，最简单的做法是根据不同的handler类型，做一个分支处理，不同的handler编写不同的代码。</p><p>​这样的问题是很明显的，分支判断复杂，代码庞大，不符合单一职责原则。如果要增加一种handler类型，需要修改代码增加分支处理，违反了开闭原则。DispatcherServelt与多个handler发生了交互，违反迪米特法则。</p><p>​而使用适配器模式，就可以很好的解决这个问题：</p><p>​不直接对handler进行处理，而是将handler交给适配器HandlerAdapter去处理，这样DispatcherServlet交互的类就只剩下一个接口，HandlerAdapter，符合迪米特法则，尽可能少的与其他类发生交互；</p><p>​将handler交给HandlerAdapter处理后，不同类型的handler被对应类型的HandlerAdapter处理，每个HandlerAdapter都只完成单一的handler处理，符合单一职责原则；</p><p>​如果需要新增一个类型的handler，只需要新增对应类型的HandlerAdapter就可以处理，无需修改原有代码，符合开闭原则。</p><p>​这样，不同的handler的不同处理方式，就在HandlerAdapter中得到了适配，对于DispatcherServlet来讲，只需要统一的调用HandlerAdapter的handle()方法就可以了，无需关注不同handler的处理细节。</p><p>设计模式的原则<br>    1.单一职责原则<br>        一个类只完成单一的功能，粒度越小越好</p><p>​2.开闭原则<br>​对扩展开放，对修改关闭。<br>​一个类开发完成后，应当可以通过扩展的方式实现新的功能，而不是通过修改原有类来达到目的。</p><p>​3.里氏替换原则<br>​所有引用父类的地方都可以透明的使用其子类</p><p>​4.依赖倒置原则<br>​抽象不应该依赖于细节，细节应该依赖于抽象。<br>​应该针对接口或抽象类编程，而不是针对具体的实现编程</p><p>​5.接口隔离原则<br>​接口的划分应该更细致，使用多个功能单一的接口，而不是将所有的功能放到一个接口中实现，客户端不应该去依赖它所不需要的接口方法。</p><p>​6.迪米特法则<br>​一个类应尽可能少的与其他类进行交互。降低耦合。</p><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;HandlerAdapter&lt;/p&gt;</summary>
    
    
    
    <category term="SpringMVC" scheme="http://zqyu.top/categories/springmvc/"/>
    
    
    <category term="Adapter" scheme="http://zqyu.top/tags/adapter/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC流程</title>
    <link href="http://zqyu.top/SpringMVC/SpringMVC%E6%B5%81%E7%A8%8B/"/>
    <id>http://zqyu.top/SpringMVC/SpringMVC%E6%B5%81%E7%A8%8B/</id>
    <published>2020-07-05T13:00:16.000Z</published>
    <updated>2020-07-08T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC执行流程</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringMVC用到的jar包--&gt;</span><br><span class="line">   &lt;!--spring-web提供监听器--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><div class="story post-story"><h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC对的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p><p>当请求进来，执行 DispatcherServlet.doDispatch(HttpServletRequest request，HttpServletResponse response)方法，列举一些比较重要的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The handler will be obtained by applying the servlet&#x27;s HandlerMappings in order.</span></span><br><span class="line"><span class="comment">     * The HandlerAdapter will be obtained by querying the servlet&#x27;s installed HandlerAdapters</span></span><br><span class="line"><span class="comment">     * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;All HTTP methods are handled by this method. It&#x27;s up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment">     * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Determine handler for the current request. 获取handler，返回HandlerExecutionChain执行链</span></span><br><span class="line">        mappedHandler = getHandler(processedRequest);</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// Determine handler adapter for the current request. 获取适配器</span></span><br><span class="line">        <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Actually invoke the handler. 根据适配器，执行目标方法</span></span><br><span class="line">        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>HandlerMapping为处理器映射器，由DispathcerServlet调用getHandler(processedRequest)方法，最终返回HandlerExecutionChain执行链，里面包括处理器handler，拦截器filter等等</p><ol><li>HandlerMapping是根据请求URl查找Handler，SpringMVC默认的HandlerMapping在文章后面</li><li>若寻找到handler，将其封装到HandlerExecutionChain返回</li><li>若寻找不到handler，看是否配置了 &lt;mvc:default-servlet-handler &#x2F;&gt;  标签，若没配置，则直接返回404，并且控制台打印：WARN  ework.web.servlet.PageNotFound  - No mapping for GET &#x2F;account&#x2F;test</li><li>若配置了&lt;mvc:default-servlet-handler &#x2F;&gt;  标签，则使用默认的HandlerMapping：**SimpleUrlHandlerMapping **，返回HandlerExecutionChain执行链，里面的handler为：org.springframework.web.servlet.resource.<strong>DefaultServletHttpRequestHandler</strong>。接着会去寻找静态资源，若找不到就404</li></ol></li><li><p>接下来确定当前请求的处理程序适配器，根据handler去确定适配器，getHandlerAdapter(mappedHandler.getHandler())，默认的HandlerMapping在文章后面</p></li><li><p>到执行处理请求的方法：ha.handle</p><ol><li>先执行拦截器的preHandler方法</li><li>调用目标Handler的目标方法得到返回值ModelAndView对象，反射执行方法看是否存在异常<ol><li>如果存在异常，则由HandlerExceptionResolver组件处理异常，得到新的ModelAndView对象</li><li>最终由试图解析器ViewResolver组件解析ModelAndView对象得到View</li><li>渲染视图</li><li>调用拦截器的afterCompletion方法</li></ol></li><li>调用拦截器的postHandler方法</li></ol></li></ol></div><div class="story post-story"><h2 id="SpringMVC-默认的映射器以及适配器"><a href="#SpringMVC-默认的映射器以及适配器" class="headerlink" title="SpringMVC 默认的映射器以及适配器"></a>SpringMVC 默认的映射器以及适配器</h2><p>默认的处理器映射器HandlerMapping：</p><ul><li>org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerMapping</strong></li><li>org.springframework.web.servlet.handler.<strong>BeanNameUrlHandlerMapping</strong></li><li>org.springframework.web.servlet.handler.<strong>SimpleUrlHandlerMapping</strong>（注意: 该映射器HandlerMapping是配置 &lt;mvc:default-servlet-handler &#x2F;&gt; 标签, 返回默认的<strong>DefaultServletHttpRequestHandler</strong>, 如果DispatcherServlet没用找到请求对应的处理器, 则会返回这个handler, 这个handler可以对静态资源进行处理）</li></ul><p>默认的处理器适配器Adapter，主要的作用是执行处理请求的方法：</p><ul><li><p>org.springframework.web.servlet.mvc.<strong>HttpRequestHandlerAdapter</strong></p></li><li><p>org.springframework.web.servlet.mvc.<strong>SimpleControllerHandlerAdapter</strong></p></li><li><p>org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerAdapter</strong></p></li></ul><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringMVC执行流程&lt;/p&gt;</summary>
    
    
    
    <category term="SpringMVC" scheme="http://zqyu.top/categories/springmvc/"/>
    
    
  </entry>
  
  <entry>
    <title>快速返回上次查看代码的位置</title>
    <link href="http://zqyu.top/idea/%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9E%E4%B8%8A%E6%AC%A1%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://zqyu.top/idea/%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9E%E4%B8%8A%E6%AC%A1%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-07-03T05:39:16.000Z</published>
    <updated>2020-07-03T14:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>快速返回上次查看代码的位置</p><span id="more"></span><div class="story post-story"><h2 id="快速返回上次查看代码的位置"><a href="#快速返回上次查看代码的位置" class="headerlink" title="快速返回上次查看代码的位置"></a>快速返回上次查看代码的位置</h2><h3 id="在IDEA中可以使用快捷键返回，默认是：ctrl-alt-方向键"><a href="#在IDEA中可以使用快捷键返回，默认是：ctrl-alt-方向键" class="headerlink" title="在IDEA中可以使用快捷键返回，默认是：ctrl + alt + 方向键"></a>在IDEA中可以使用快捷键返回，默认是：ctrl + alt + 方向键</h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;快速返回上次查看代码的位置&lt;/p&gt;</summary>
    
    
    
    <category term="idea" scheme="http://zqyu.top/categories/idea/"/>
    
    
    <category term="idea" scheme="http://zqyu.top/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>aop</title>
    <link href="http://zqyu.top/Spring/aop/"/>
    <id>http://zqyu.top/Spring/aop/</id>
    <published>2020-07-02T06:35:37.000Z</published>
    <updated>2020-07-02T06:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>aop定义及源码</p><span id="more"></span><div class="story post-story"><h2 id="什么是aop？"><a href="#什么是aop？" class="headerlink" title="什么是aop？"></a>什么是aop？</h2><p>​与00P对比，面向切面,传统的00P开发中的代码逻辑是至上而下的,在这些至上而下的过程中会产生一些横切性的问题 ,这些横切性的问题和我们的主业务逻辑关系不大,会散落在代码的各个地方,造成难以维护, AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>日志记录</li><li>权限认证</li><li>效率检查</li><li>事务管理</li><li>............</li></ul><p>横切性问题：相对于oop而言，一些跟业务逻辑没有关系，会散落再业务逻辑的各个地方这些代码，这些会造成代码很难维护。</p><p>oop跟多关注的是业务逻辑的处理，而aop关注的是切面的处理</p><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;aop定义及源码&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://zqyu.top/categories/spring/"/>
    
    
    <category term="aop" scheme="http://zqyu.top/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>bean生命周期源码</title>
    <link href="http://zqyu.top/Spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://zqyu.top/Spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-07-01T14:20:27.000Z</published>
    <updated>2020-07-08T04:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>bean生命周期源码</p><span id="more"></span><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;bean生命周期源码&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://zqyu.top/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>类的实例化顺序</title>
    <link href="http://zqyu.top/Java/basics/class_instantiation/"/>
    <id>http://zqyu.top/Java/basics/class_instantiation/</id>
    <published>2020-06-30T13:40:38.000Z</published>
    <updated>2020-06-30T13:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>类的实例化顺序？</p><span id="more"></span><div class="story post-story"><h2 id="java类的实例化顺序"><a href="#java类的实例化顺序" class="headerlink" title="java类的实例化顺序"></a>java类的实例化顺序</h2><ul><li>1． 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li><li>2． 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li><li>3． 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li><li>4． 父类构造方法</li><li>5． 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li><li>6． 子类构造方法</li></ul><h3 id="总结：父类静态成员和静态代码块-gt-子类静态成员和静态代码块-gt-父类非静态成员和非静态代码块-gt-父类构造方法-gt-子类非静态成员和非静态代码块-gt-子类构造方法"><a href="#总结：父类静态成员和静态代码块-gt-子类静态成员和静态代码块-gt-父类非静态成员和非静态代码块-gt-父类构造方法-gt-子类非静态成员和非静态代码块-gt-子类构造方法" class="headerlink" title="总结：父类静态成员和静态代码块-&gt;子类静态成员和静态代码块-&gt;父类非静态成员和非静态代码块-&gt;父类构造方法-&gt;子类非静态成员和非静态代码块-&gt;子类构造方法"></a>总结：父类静态成员和静态代码块-&gt;子类静态成员和静态代码块-&gt;父类非静态成员和非静态代码块-&gt;父类构造方法-&gt;子类非静态成员和非静态代码块-&gt;子类构造方法</h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;类的实例化顺序？&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="class" scheme="http://zqyu.top/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>Socket通讯原理</title>
    <link href="http://zqyu.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/Socket/"/>
    <id>http://zqyu.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/Socket/</id>
    <published>2020-06-30T09:16:53.000Z</published>
    <updated>2020-06-30T12:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是TCP&#x2F;IP、UDP？</li><li>Socket在哪里？</li><li>Socket是什么？</li></ul><span id="more"></span><div class="story post-story"><h2 id="什么是TCP-x2F-IP、UDP？"><a href="#什么是TCP-x2F-IP、UDP？" class="headerlink" title="什么是TCP&#x2F;IP、UDP？"></a>什么是TCP&#x2F;IP、UDP？</h2><p>​TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）即传输控制协议&#x2F;网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP&#x2F;IP协议族中的一种。</p><p>​这里有一张图，表明了这些协议的关系，如如下图1所示：</p><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\20180913104811138.jpg" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\20180913104811138.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TCP/IP、UDP"></p><p>​TCP&#x2F;IP协议族包括运输层、网络层、链路层。现在你知道TCP&#x2F;IP与UDP的关系了吧。</p></div><div class="story post-story"><h2 id="Socket在哪里呢？"><a href="#Socket在哪里呢？" class="headerlink" title="Socket在哪里呢？"></a>Socket在哪里呢？</h2><p>​在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。如下图2所示：</p><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\2018091310482621.jpg" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\2018091310482621.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Socket"></p></div><div class="story post-story"><h2 id="Socket是什么呢？"><a href="#Socket是什么呢？" class="headerlink" title="Socket是什么呢？"></a>Socket是什么呢？</h2><p>​Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p></div><div class="story post-story"><h2 id="你会使用它们吗？"><a href="#你会使用它们吗？" class="headerlink" title="你会使用它们吗？"></a>你会使用它们吗？</h2><p>​前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。</p><p>​例如：一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景解释了这工作原理，也许TCP&#x2F;IP协议族就是诞生于生活中。</p><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\20180913104844708.jpg" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\20180913104844708.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Socket图解"></p><p>​先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><hr><p>​我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页 时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠Socket？那什么是 Socket？Socket的类型有哪些？还有Socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：</p></div><div class="story post-story"><h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>​上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix&#x2F;Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write&#x2F;read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读&#x2F;写IO、打开、关闭）。</p></div><div class="story post-story"><h2 id="网络中进程之间是如何通信的？"><a href="#网络中进程之间是如何通信的？" class="headerlink" title="网络中进程之间是如何通信的？"></a>网络中进程之间是如何通信的？</h2><ul><li><p>消息传递（管道、FIFO、消息队列）</p></li><li><p>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</p></li><li><p>共享内存（匿名的和具名的）</p></li><li><p>远程过程调用（Sun RPC）</p></li></ul><p>​但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程的PID来唯一标识一个进程，但是在网络中这是不可行的。其实TCP&#x2F;IP协议族已经帮我们解决了这个问题，网络层的“IP地址”可以表示这个网络中的主机，而传输层的“协议 + 端口”可以唯一表示主机中的应用程序（进程）。这样利用三元组（IP地址、协议、端口）就可表示网络主机的进程，网络中的进程用就可以利用这个标志与其他进程进行交互。</p><p>​使用TCP&#x2F;IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（Socket）和UNIX System V的TLI（淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用小恒徐都是采用Socket，而现在又是网络时代，网络中进程通信时无处不在（“一切皆Socket”）。</p></div><div class="story post-story"><h2 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h2><p>概念：</p><p>​TCP&#x2F;IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p><p>​它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。</p><p>​TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。<br> TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”</span><br><span class="line">[Shake 2] 套接字B：“好的，我这边已准备就绪。”</span><br><span class="line">[Shake 3] 套接字A：“发送连接请求。”</span><br></pre></td></tr></table></figure><p>TCP数据报结构，如下图1-1所示：</p><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-bf1bffccd9cceaff.webp" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-bf1bffccd9cceaff.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TCP数据报结构"></p><p>带阴影的几个字段需要重点说明一下：</p><ul><li>序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</li><li>确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack &#x3D; Seq + 1。</li><li>标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下： <ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：建立一个新连接。</li><li>FIN：断开一个连接。</li></ul></li></ul><h3 id="连接的建立（三次握手）：使用-connect-建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2："><a href="#连接的建立（三次握手）：使用-connect-建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2：" class="headerlink" title="连接的建立（三次握手）：使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2："></a>连接的建立（三次握手）：使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2：</h3><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-75c208edcfb986fc.webp" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-75c208edcfb986fc.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三次握手"></p><p>​客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求<br>​ 这时客户端发起请求：</p><ul><li>当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。</li><li>服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包<br> 　服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。<br>　服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。<br>　服务器将数据包发出，进入SYN-RECV状态</li><li>客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。<br> 　接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。<br>　客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。</li><li>服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。<br> 　至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。</li></ul><h3 id="TCP四次握手断开连接"><a href="#TCP四次握手断开连接" class="headerlink" title="TCP四次握手断开连接"></a>TCP四次握手断开连接</h3><p>​建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。<br> 断开连接需要四次握手，可以形象的比喻为下面的对话：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”</span><br><span class="line">[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”</span><br><span class="line">等待片刻后……</span><br><span class="line">[Shake 3] 套接字B：“我准备好了，可以断开连接了。”</span><br><span class="line">[Shake 4] 套接字A：“好的，谢谢合作。”</span><br></pre></td></tr></table></figure><p>下图演示了客户端主动断开连接的场景：</p><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-63aad9661131a2a8.webp" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-63aad9661131a2a8.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="客户端主动断开连接"></p><p>​建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：</p><ul><li><p>客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p></li><li><p>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。<br> 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p></li><li><p>客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</p></li><li><p>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</p></li><li><p>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</p></li><li><p>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。</p></li></ul><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a><strong>OSI模型</strong></h3><p>TCP&#x2F;IP对OSI的网络模型层进行了划分如下：</p><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-d6275ac25abac5cc.webp" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-d6275ac25abac5cc.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="网络模型层"></p><p>TCP&#x2F;IP协议参考模型把所有的TCP&#x2F;IP系列协议归类到四个抽象层中</p><ul><li>应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等</li><li>传输层：TCP，UDP</li><li>网络层：IP，ICMP，OSPF，EIGRP，IGMP</li><li>数据链路层：SLIP，CSLIP，PPP，MTU</li><li>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</li></ul><p><img src="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-2d26013c75ee45e1.webp" class="lazyload" data-srcset="C:\Users\Yuqiang\Desktop\blog-master\source_posts\计算机网络基础\11362584-2d26013c75ee45e1.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="参考文章链接："><a href="#参考文章链接：" class="headerlink" title="参考文章链接："></a>参考文章链接：</h3><ul><li><a href="https://blog.csdn.net/jiushimanya/article/details/82684525" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/jiushimanya/article/details/82684525</a></li><li><a href="https://www.jianshu.com/p/066d99da7cbd" target="_blank" rel="noopener external nofollow noreferrer">https://www.jianshu.com/p/066d99da7cbd</a></li></ul><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;什么是TCP&amp;#x2F;IP、UDP？&lt;/li&gt;
&lt;li&gt;Socket在哪里？&lt;/li&gt;
&lt;li&gt;Socket是什么？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机网络基础" scheme="http://zqyu.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Socket" scheme="http://zqyu.top/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 中的几种基本数据类型</title>
    <link href="http://zqyu.top/Java/basics/data_type/"/>
    <id>http://zqyu.top/Java/basics/data_type/</id>
    <published>2020-06-30T04:49:36.000Z</published>
    <updated>2020-06-30T12:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA 中的几种基本数据类型是什么，各自占用多少字节。 </p><span id="more"></span><div class="story post-story"><h2 id="Java共有8中基本数据类型"><a href="#Java共有8中基本数据类型" class="headerlink" title="Java共有8中基本数据类型"></a>Java共有8中基本数据类型</h2><table><thead><tr><th>基本数据类型</th><th>占用空间</th></tr></thead><tbody><tr><td>boolean</td><td>1&#x2F;8个字节（1bit）</td></tr><tr><td>byte</td><td>1个字节</td></tr><tr><td>short</td><td>2个字节</td></tr><tr><td>char</td><td>2个字节</td></tr><tr><td>int</td><td>4个字节</td></tr><tr><td>float</td><td>4个字节</td></tr><tr><td>long</td><td>8个字节</td></tr><tr><td>double</td><td>8个字节</td></tr></tbody></table><p>其中：</p><ul><li>bit（位）：位是计算机中存储数据的最小单位，指二进制数中的一个位数，其值为“0”或“1”</li><li>byte（字节）：字节是计算机存储容量的基本单位，一个字节由8位二进制数组成。在计算机内部，一个字节可以表示一个数据，也可以表示一个英文字母，两个字节可以表示一个汉字</li></ul><hr><br><br><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;JAVA 中的几种基本数据类型是什么，各自占用多少字节。 &lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="Java数据类型" scheme="http://zqyu.top/tags/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS setTimeout</title>
    <link href="http://zqyu.top/Js/setTimeout/"/>
    <id>http://zqyu.top/Js/setTimeout/</id>
    <published>2020-06-27T13:40:10.000Z</published>
    <updated>2023-03-23T10:27:02.488Z</updated>
    
    <content type="html"><![CDATA[<p>使用循环时，用来延迟执行方法</p><span id="more"></span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_this.<span class="property">data</span>.<span class="property">imgs</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e, index</span>) &#123;</span><br><span class="line">    <span class="comment">// 采用闭包的方式来立即执行setTimeout，每隔500毫秒执行方法</span></span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            _this.<span class="title function_">uploadImg</span>(e);</span><br><span class="line">        &#125;, index * <span class="number">1000</span>);</span><br><span class="line">    &#125;)(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用循环时，用来延迟执行方法&lt;/p&gt;</summary>
    
    
    
    <category term="Js" scheme="http://zqyu.top/categories/js/"/>
    
    
    <category term="setTimeout" scheme="http://zqyu.top/tags/settimeout/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList与LinkedList</title>
    <link href="http://zqyu.top/Java/List/ArrayList_LinkedList/"/>
    <id>http://zqyu.top/Java/List/ArrayList_LinkedList/</id>
    <published>2020-06-21T01:55:31.000Z</published>
    <updated>2020-06-30T12:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList与LinkedList主要区别</p><span id="more"></span><p>ArrayList底层结构是<strong>数组</strong></p><p>LinkedList底层结构是<strong>链表</strong></p><p>所以主要区别是<strong>数组与链表的区别</strong></p><h3 id="ArrayList：基于数组数据结构"><a href="#ArrayList：基于数组数据结构" class="headerlink" title="ArrayList：基于数组数据结构"></a>ArrayList：基于数组数据结构</h3><ul><li>查询快，在堆（heap）内存是连续的内存空间支持随机访问</li><li>插入和删除的效率比较低，插入需要扩容，删除需要移动元素</li><li>根据内容查找元素的效率较低</li></ul><h3 id="LinkedList：基于链表数据结构"><a href="#LinkedList：基于链表数据结构" class="headerlink" title="LinkedList：基于链表数据结构"></a>LinkedList：基于链表数据结构</h3><ul><li>插入和删除的效率高，非常适合经常增加、删除操作的场景</li><li>查询在量大的时候较慢，链表查询，需要从表头或者表尾逐一遍历查询</li></ul><h3 id="共同点都不是线程安全的"><a href="#共同点都不是线程安全的" class="headerlink" title="共同点都不是线程安全的"></a>共同点都不是线程安全的</h3><h3 id="如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍"><a href="#如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍" class="headerlink" title="如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍"></a>如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍</h3><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;ArrayList与LinkedList主要区别&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="List" scheme="http://zqyu.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="http://zqyu.top/Java/List/LinkedList/"/>
    <id>http://zqyu.top/Java/List/LinkedList/</id>
    <published>2020-06-09T05:40:26.000Z</published>
    <updated>2020-06-30T12:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>LinkedList实现原理</p><span id="more"></span><h1 id="阅读本篇文章需要数据结构-链表（双向链表）-的基础"><a href="#阅读本篇文章需要数据结构-链表（双向链表）-的基础" class="headerlink" title="阅读本篇文章需要数据结构 链表（双向链表） 的基础"></a>阅读本篇文章需要数据结构 链表（双向链表） 的基础</h1><p>如何简单使用，创建一个LinkedList对象，并且调用add方法新增一个元素</p><div class="story post-story"><h2 id="先来看看不指定插入的位置"><a href="#先来看看不指定插入的位置" class="headerlink" title="先来看看不指定插入的位置"></a>先来看看不指定插入的位置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    list.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就这么两句话，它运行时是如何实现的呢？</p><p>点击进去看源码！</p><ul><li>构造器，并没有执行任何的操作，只是构造一个空链表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>add方法，看到方法称以及注释，可知道新增节点采用的是尾插法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再看具体任何新增节点的细节，进去看看linkLast方法</li><li>这是一个很标准的尾插法操作：先将尾节点的引用赋值给 l ，然后创建一个新节点，该节点的前驱（prev）为 l ，数据（item）为 e ，后继（next）为null</li><li>接下来判断该新增节点是否为链表的第一个节点，如果是，则将该节点的引用赋值给 first ，否则将新增节点地址赋值给l.next</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Links e as last element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="story post-story"><h2 id="再看看指定插入的位置"><a href="#再看看指定插入的位置" class="headerlink" title="再看看指定插入的位置"></a>再看看指定插入的位置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体方法实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment">* Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment">* subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先执行checkPositionIndex，校验index是否合法，具体实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tells if the argument is the index of a valid position for an</span></span><br><span class="line"><span class="comment">* iterator or an add operation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后回判断插入的位置是否为尾节点，如果是则执行上面所说的尾插法，否则执行linkBefore方法，需要参数（E e, Node<E> succ），而所需要的 succ 形参需要调用node方法获取到。</li><li>看node方法，根据index（索引）获取到所对应的节点。判断的方法类似二分查找法，链表查找都需要逐一遍历，所以需要判断从头节点还是尾节点开始遍历查找。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接下来看linkBefore方法，这个也是双向链表基本的操作。</p><p><img src="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png" class="lazyload" data-srcset="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双向链表插入某个位置"></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;    </span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;LinkedList实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="List" scheme="http://zqyu.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList</title>
    <link href="http://zqyu.top/Java/List/ArrayList/"/>
    <id>http://zqyu.top/Java/List/ArrayList/</id>
    <published>2020-06-08T13:46:57.000Z</published>
    <updated>2020-06-30T12:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList实现原理</p><span id="more"></span><hr><div class="story post-story"><h2 id="如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素"><a href="#如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素" class="headerlink" title="如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素"></a>如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就这么两句话，它运行时是如何实现的呢？</p><p>点击进去看源码！</p><h3 id="当不指定数组长度时"><a href="#当不指定数组长度时" class="headerlink" title="当不指定数组长度时"></a>当不指定数组长度时</h3><ul><li><p>构造器（构造函数）：此构造器没有参数，并且也没有数组初始化，就只有一句 this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA 。问题来了，是什么时候开始初始化数组？初始化的长度是多少？带着这个问题，继续往下面看。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当调用add方法时，点击进去查看源代码，在真正赋值的操作前，执行了ensureCapacityInternal，参数是 size + 1 ，size表示当前ArrayList的大小，此参数的意义是判断 size + 1 后，数组索引是否越界，所以这个方法是保证在赋值前数组索引是否越界（是否需要扩容）以及记录ArrayList结构性变化的次数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 在赋值前，记录modCount（modCount，记录ArrayList结构性变化的次数）以及判断是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>点进去ensureCapacityInternal方法，上来就一个判断，这个判断是什么意思？回过头来看一下空构造器，这句话不就是判断的条件吗？</p></li><li><p>构造器出现的 this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;那么它是什么意思呢？按照字面意思是表示一种状态，当 elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表采用默认的长度 DEFAULT_CAPACITY （10），以确保在第一次添加元素时要扩容的大小。</p></li><li><p>判断条件成立，执行Math.max，在DEFAULT_CAPACITY（10）和minCapacity（1）之间取最大值，以确保在第一次添加元素时要扩容的大小，获取到最大值后将它赋值给minCapacity（10），接着执行ensureExplicitCapacity方法并传入参数minCapacity，具体往后面看。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Default initial capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">* distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">* first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">* The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续来看看ensureExplicitCapacity方法源码，上来就modCount++，表示ArrayList结构性变化的次数加一，接着判断数组索引是否越界（是否需要扩容）。此时，当创建ArrayList对象时，只是初始化空数组，并没有指定数组长度，所以elementData.length &#x3D; 0，而minCapacity是传过来的参数10，所以该判断条件是成立的，需要执行grow方法进行扩容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里需要注意的是：minCapacity &#x3D; 10，elementData.length &#x3D; 0。这里不理解的还需要再回到前面去看看。</p></li><li><p>当执行到扩容语句时，此时的elementData.length &#x3D; 0，所以扩容之后还是0，这个时候就有疑问了，扩容之后还是0？接下来的一个判断起到关键性的作用，也是专门判断扩容之后的长度比原来小的问题，当扩容后的长度比原先的小时，最终是按照原先的大小进行扩容，再下面就是数组copy扩容了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">* number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 这里确定扩容的大小，比原来大1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>刚开始写的博客，可能表达的有点不清楚，请见谅</strong></p><blockquote><h4 id="总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1-5倍。"><a href="#总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1-5倍。" class="headerlink" title="总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1.5倍。"></a>总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1.5倍。</h4></blockquote></div><div class="story post-story"><h2 id="当指定数组长度："><a href="#当指定数组长度：" class="headerlink" title="当指定数组长度："></a>当指定数组长度：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><h4 id="结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10"><a href="#结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10" class="headerlink" title="结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10."></a>结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10.</h4></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">*         is negative</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;ArrayList实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="List" scheme="http://zqyu.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer与StringBuilder</title>
    <link href="http://zqyu.top/Java/String/StringBuffer_StringBuilder/"/>
    <id>http://zqyu.top/Java/String/StringBuffer_StringBuilder/</id>
    <published>2020-06-07T04:41:39.000Z</published>
    <updated>2020-06-30T12:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>StringBuffer与StringBuilder主要的区别</p><span id="more"></span><hr><div class="story post-story"><h2 id="话不多说，先先看源码（JDK1-8）"><a href="#话不多说，先先看源码（JDK1-8）" class="headerlink" title="话不多说，先先看源码（JDK1.8）"></a>话不多说，先先看源码（JDK1.8）</h2><p>StringBuffer类的append方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder类的append方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显可以看出，<strong>StringBuffer类的append方法被synchronized关键字修饰，而StringBuilder类的append方法没有被synchronized修饰。</strong></p><p><strong>Tips：被synchronized修改的方法或者代码块可以保证在同一时刻，只有一个线程可以执行，同时还可以保证线程的可见性</strong>。</p></div><div class="story post-story"><h2 id="结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。"><a href="#结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。" class="headerlink" title="结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。"></a>结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。</h2><h2 id="String是字符串不可变对象-StringBuffer、StringBuild-可变对象-StringBuffer线程安全-其中方法用synchronized修饰"><a href="#String是字符串不可变对象-StringBuffer、StringBuild-可变对象-StringBuffer线程安全-其中方法用synchronized修饰" class="headerlink" title="String是字符串不可变对象, StringBuffer、StringBuild,可变对象 StringBuffer线程安全,其中方法用synchronized修饰"></a>String是字符串不可变对象, StringBuffer、StringBuild,可变对象 StringBuffer线程安全,其中方法用synchronized修饰</h2><p>除了synchronized关键字外，StringBuffer类还多了个<strong>toStringCache</strong>成员变量，这个变量是干什么的呢？来看一下源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment">* whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">char</span>[] toStringCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从官方字面意思来说是返回最后一次toString的缓存值，一但被修改就清除这个值。</p><p>当多个线程同时访问时，StringBuffer虽然是线程安全的，但是性能低效，所以加一个缓存来平衡一下StringBuffer的性能。</p><hr><br /><br /><span class='btn large center'><a class="button" href='<https://github.com/itqiangyu/itqiangyu.github.io/issues>' title='向博主反馈问题'><i class='fas fa-paper-plane'></i>向博主反馈问题</a></span></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;StringBuffer与StringBuilder主要的区别&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://zqyu.top/categories/java/"/>
    
    
    <category term="String" scheme="http://zqyu.top/tags/string/"/>
    
  </entry>
  
</feed>
